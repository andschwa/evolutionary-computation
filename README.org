#+TITLE:     Project #2b Genetic Program
#+AUTHOR:    Andrew Schwartzmeyer
#+EMAIL:     schw2620@vandals.uidaho.edu
#+DATE:      2014-03-02 Sun
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:

* Build :noexport:
Makes use of autotools. Necessary files:
- configure.ac (with help from autoscan)
- Makefile.am
- m4/* for macros

To configure and build:
#+begin_src sh
autoreconf -vfi
./configure && make
#+end_src

* Assignment :noexport:
** DONE Project #2a Genetic Program
   DEADLINE: <2014-03-07 Fri>
[[http://www2.cs.uidaho.edu/~cs472_572/s14/GPProjectA.html][From Professor Terry Soule]]
This is the first subproject of the GP project. The goal of this
subproject is to create a population of GP tree structures for a
symbolic regression problem.  If you want to use it, or refer to it, I
have written a node and an individual class that uses pointers to
build and evaluate random expression trees. Trees are build of nodes,
which point to each other.

node.h
node.cpp
individual.h
individual.cpp
test.cpp

To compile the test main program use:

=g++ test.cpp node.cpp individual.cpp=

For this subproject you only need the following functionallity:

- Generate full random expression individuals.
- The expression trees should have, at least, the non-teminals: +,
  -, *, /.
- The expression trees should have, at least, the teminals: X (the
  input variable) and constants.
- The ability to copy individuals.
- The ability to evaluate individuals.
- The ability to erase individuals.
- The ability to calculate the size (number of terminals and
  non-terminals) of individuals.
- The ability to create a population of individuals and to find the
  best and average fitness of the population, and the average size of
  the individuals in the population.
- Individuals should represent expression trees, but may be coded as a
  different type of data structure (e.g. a tree stored in an
  array). For now you may choose your own fitness function, i.e. your
  own set of x,y points that the GP should evolved an expression to
  fit.

For the report:

- Project Write-up: Write a short paper describing the results of your
  project that includes the following sections:
- Algorithm descriptions - Description of the GP so far. Be careful to
  include all of the details someone would need to replicate your
  work.
- Individual description - Description of the structure of your
  individuals. Be careful to include all of the details someone would
  need to replicate your work.
- Results - Basically, does it seem to be working.
- Conclusions - If it's not working, why not. And what are then next
  steps to complete the project.

** DONE Project #2b Genetic Program
   DEADLINE: <2014-03-14 Fri>
This is the second subproject of the GP project. The goal of this subproject is to finish the pieces of the GP for a symbolic regression problem.
For this subproject you will need to complete the GP including the following functionallity (in addition to the functions from the previous assignment):

- [X] Add a conditional to the function set of the expression trees.
- [X] Mutation
- [X] Crossover of two trees
- [X] Selection
- [X] Elitism if you are using a generational model
- [X] Test the GP to make sure that it is working.

Project Write-up: For this subproject you only need a description of
the general algorithm:

- [X] generational or steady-state
- [X] how mutation works
- [X] the selction mechanism, etc.
- [X] a description of any problems so far

Note that the write-up may be fairly short.
** TODO Project #2 Genetic Program
   DEADLINE: <2014-03-23 Sun>

This is the final part of Project 2. For this project you need to
present a summary of your GP program and the results. Here is a
template for the summary in Word and pdf (and the latex). Note that
for this project you do not need to do a lot of writting. An abstract,
fill in the table summarizing your algorithms, two graphs, and a
conclusion/discussion.

* Algorithm

This Genetic Program far creates a population of 256 random
=Individual= objects, which are parse trees with a configurable
maximum depth (currently starting at 3), stored in a =std::vector=
container. The algorithm is generational. For each iteration of the
algorithm, (up to the maximum number of iterations, currently 256), a
new offspring generation is created to replace the last. To do this,
first the best individual is saved (found using =std::min_element= on
the individuals' fitnesses, dicussed in the next paragraph) for later
elitism replacement. Next, a new offspring generation is generated by
selecting two parents at a time from the current population
(tournament selection of size 3; that is, the most fit of 3 randomly
drawn individuals is selected). For each set of parents, there is an
80 percent chance they will undergo crossover. If they do, then for
each parent, there is a 90 percent chance that its chosen replacement
node is an internal node, otherwise it is a leaf node. Using the
replacement nodes as the root nodes of their respective subtrees,
these subtrees are then swapped between the parents (by replacing the
nodes with each other). After this, both recombined individuals
undergo a single-node mutation sequence, where for each node in the
individual, there is a 0.02 percent chance it will mutate to a
different function of the same arity. The nodes are then added to the
offspring population. This entire process is repeated until an the new
generation is the necessary size (that is, 256 individuals).

The fitness is the square root of the sum of the calculated errors for
each input. The error is the square of the difference between the
function's evaluation and the expected output for the respective
input. This evaluation function was provided by Terry Soule, and works
well as far as biasing toward fixing larger errors is concerned,
although as mentioned it gives a well-fit but shifted function an
overly bad fitness. Additionally, a size penalty is added to the
fitness (so that the trees do not grow out of control). This penalty
is currently the square root of the the product of the total size of
the individual and a constant factor (0.1).

This program takes full advantage of multi-processing. For simplicity
it was not mentioned earlier; however, for the "generate new
offspring" step, the task is doled out in blocks equal to the
necessary size of the population divided by the optimal number of
threads for the current processor (in my case, this value is four
since my Intel i5 is hyper-threaded and dual-core). These blocks are
each executed in their own thread (using the C++11 =std::async= and
=std::future= templates), and then on completion reassambled into the
final offspring population. Logging to the log file is also done in
its own thread, using =std::thread= at the beginning of each
iteration, and is then joined at the end of each iteration. I have
also profiled the algorithm, and found that with threads, on this
machine I experience a speed improvement of about a factor of two
(which was to be expected). While profiling I also ensured that the
program contains no memory leaks (easy enough without pointers), and
can therefore be run essentially indefinitely. If given the chance, I
would very much like to executed it on Dr. Jeffery's 32 (or is it 64?)
core machine. At the least, I am going to compile it natively on my
desktop, which has an AMD Athlon II X4 645 quad-core processor,
clocked at 3.1 GHz, that I can overclock pretty easily to 3.7 GHz (any
further would require a lot more work).

Additionally, instead of using the built-in =time= command to measure
performance, I used the C++11 =std::chrono= library to accurately time
exactly the execution duration of the algorithm. For the final report
(when I have good results), the precise durations will be included.

* Individual

The =Individual= class is modeled after Terry Soule's code, but
updated with fancy C++11 extensions. An =Individual= object holds an
instance of a =Problem= class, a =Size= struct, a fitness as a double,
and a root =Node= object. In addition to the constructor and several
"getter" functions, it has the methods =evaluate()=, =print_formula()=, and
=print_calculation()=.

When constructed, an =Individual= instantiates a root =Node= and gives
it a maximum depth (provided by the =Problem= object); the root then
recursively creates a filled tree of random non-terminal / internal
nodes and terminal / leaf nodes. After the tree is constructed, the
fitness and size of the =Individual= is assigned the result of its
=evaluate()= method and the root =Node='s =size()= method
respectively.

The =evaluate()= method delegates to the root =Node= and recursively
evaluates the parse tree for each pair of inputs from the =Problem=
values vector. The =evaluate(X)= method of the =Node= evaluates the
expression tree recursively for the given input =X= (as a
double). This is a depth-first post-order traversal. For the binary
=+, -, *, /= operators, the left and right nodes are evaluated before
the result is returned, and the arity of the =Node= is two. The
implementation of addition, subtraction, and multiplication are
trivial, but the division is protected: if the denominator is zero,
the function returns one, otherwise it returns the expected
division. For the =< and >= comparisons, the =Node= has an arity of
four (a, b, c, and d), and returns =a < (or >) b ? c : d=, that is, if
a is less than (or greater than) b, return c, otherwise return d (the
four children are of course evaluated first). The leaf nodes have an
arity of zero, and return either a constant drawn from a
=std::uniform_real_distribution= with the range =[0, 10]=, or the
provided input value =X=. Also implemented are several unary
operators: square root, trigonometric sine and cosine, natural
logarithm, and natural exponential function; however, these are not
generally used on the current set of test data.

The =size()= method of the =Node= recursively counts the number of
internal and leaf nodes, and returns a =Size= struct which is a simple
pair of integers represented the aforementioned counts (I am somewhat
surprised that I am not just using a =std::tuple= here, but the
=struct= fits better).

The construction of the =Node= is quite simple: given the depth, if it
is less than the =Problem='s maximum depth, the =Node= is a assigned a
random non-terminal type (one of =+, -, *, /, <, >=), and then
recursively adds the necessary number of new =Node= objects to its
children =vector= (two for binary types, four for the
conditionals). If the maximum depth has been reached, the node is
assigned a random terminal type (either a constant or the input), and
does not create any children. When assigned a constant type, it
receives a =const double= value drawn from the aforementioned
distribution. Because the =Node= class is not derived, internal nodes
have some overhead in the form of the allocated space for a double to
hold that constant.

The =print()= method of =Node= class performs a recursive depth-first
post-order traversal, printing the tree's expression to standard out
in Reverse Polish Notation. The =print_formula()= method of the
=Individual= class first prints the total number of nodes, number of
internal nodes, and number of leaf nodes, and then calls the root's
=print()= method to provide the formula. The =print_calculation()=
method is more verbose version of =evaluate()=, where the input/output
pair and respective calculated output are printed as the evaluation
runs. This will be re-factored later into a verbosity option on the
standard =evaluate()= function.

* Conclusion

After fixing the crossover and mutation bugs (at one point my mutation
was ignoring my disabled functions and including them anyway, and my
crossover was not actually swapping the subtrees, ha), the algorithm
works decently well, but must be tweaked much further.
