#+TITLE:     Project #2a Genetic Program
#+AUTHOR:    Andrew Schwartzmeyer
#+EMAIL:     schw2620@vandals.uidaho.edu
#+DATE:      2014-03-02 Sun
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:

* Build :noexport:
Makes use of autotools. Necessary files:
- configure.ac (with help from autoscan)
- Makefile.am
- src/Makefile.am
- m4/AX_CXX_COMPILE_STDCXX_11.m4 (for C++11 macro)

To configure and build:
#+begin_src sh
autoreconf -vfi
./configure && make
#+end_src

* Assignment :noexport:
** DONE Project #2a Genetic Program
   DEADLINE: <2014-03-07 Fri>
[[http://www2.cs.uidaho.edu/~cs472_572/s14/GPProjectA.html][From Professor Terry Soule]]
This is the first subproject of the GP project. The goal of this
subproject is to create a population of GP tree structures for a
symbolic regression problem.  If you want to use it, or refer to it, I
have written a node and an individual class that uses pointers to
build and evaluate random expression trees. Trees are build of nodes,
which point to each other.

node.h
node.cpp
individual.h
individual.cpp
test.cpp

To compile the test main program use:

=g++ test.cpp node.cpp individual.cpp=

For this subproject you only need the following functionallity:

- Generate full random expression individuals.
- The expression trees should have, at least, the non-teminals: +,
  -, *, /.
- The expression trees should have, at least, the teminals: X (the
  input variable) and constants.
- The ability to copy individuals.
- The ability to evaluate individuals.
- The ability to erase individuals.
- The ability to calculate the size (number of terminals and
  non-terminals) of individuals.
- The ability to create a population of individuals and to find the
  best and average fitness of the population, and the average size of
  the individuals in the population.
- Individuals should represent expression trees, but may be coded as a
  different type of data structure (e.g. a tree stored in an
  array). For now you may choose your own fitness function, i.e. your
  own set of x,y points that the GP should evolved an expression to
  fit.

For the report:

- Project Write-up: Write a short paper describing the results of your
  project that includes the following sections:
- Algorithm descriptions - Description of the GP so far. Be careful to
  include all of the details someone would need to replicate your
  work.
- Individual description - Description of the structure of your
  individuals. Be careful to include all of the details someone would
  need to replicate your work.
- Results - Basically, does it seem to be working.
- Conclusions - If it's not working, why not. And what are then next
  steps to complete the project.

** TODO Project #2b Genetic Program
   DEADLINE: <2014-03-14 Fri>
This is the second subproject of the GP project. The goal of this subproject is to finish the pieces of the GP for a symbolic regression problem.
For this subproject you will need to complete the GP including the following functionallity (in addition to the functions from the previous assignment):

- Add a conditional to the function set of the expression trees.
- Mutation
- Crossover of two trees
- Selection
- Elitism if you are using a generational model
- Test the GP to make sure that it is working.

Project Write-up: For this subproject you only need a description of
the general algorithm:

- generational or steady-state
- how mutation works
- the selction mechanism, etc.
- a description of any problems so far

Note that the write-up may be fairly short.
** TODO Project #2 Genetic Program
   DEADLINE: <2014-03-23 Sun>

This is the final part of Project 2. For this project you need to
present a summary of your GP program and the results. Here is a
template for the summary in Word and pdf (and the latex). Note that
for this project you do not need to do a lot of writting. An abstract,
fill in the table summarizing your algorithms, two graphs, and a
conclusion/discussion.

* Algorithm

The Genetic Program thus far creates a population of 256 random
=Individual= objects, which are parse trees with a configurable
maximum depth (tested up to a depth of 10), stored in a =std::vector=
container. The test "algorithm" finds the best and average fitness of
the population by using the =std::min_element= and =std::accumulate=
algorithms respectively. The average size is also calculated using
=std::accumulate= (and of course dividing by the population size, same
goes for average fitness). With C++11's lambdas, these calculations go
from messy for loops to one-line STL calls, it's pretty cool. With the
best =Individual= retrieved, the test code then prints out the formula
in Reverse Polish Notation, and the evaluation of each input coupled
with the calculated error from the output.

The fitness is the square root of the sum of the calculated errors for
each input. The error is the square of the difference between the
function's evaluation and the expected output for the respective
input. This evaluation function was provided by Terry Soule, and works
well as far as biasing toward fixing larger errors is concerned,
although as mentioned it gives a well-fit but shifted function an
overly bad fitness.

* Individual

The =Individual= class is modeled after Terry Soule's code, but
updated with fancy C++11 extensions. An =Individual= object holds an
instance of a =Problem= class, a =Size= struct, a fitness as a double,
and a root =Node= object. In addition to the constructor and several
"getter" functions, it has the methods =evaluate()=, =print_formula()=, and
=print_calculation()=.

When constructed, an =Individual= instantiates a root =Node= and gives
it a maximum depth (provided by the =Problem= object); the root then
recursively creates a filled tree of random non-terminal / internal
nodes and terminal / leaf nodes. After the tree is constructed, the
fitness and size of the =Individual= is assigned the result of its
=evaluate()= method and the root =Node='s =size()= method
respectively.

The =evaluate()= method delegates to the root =Node= and recursively
evaluates the parse tree for each pair of inputs from the =Problem=
values vector. The =evaluate(X)= method of the =Node= evaluates the
expression tree recursively for the given input =X= (as a
double). This is a depth-first post-order traversal. For the binary
=+, -, *, /= operators, the left and right nodes are evaluated before
the result is returned, and the arity of the =Node= is two. The
implementation of addition, subtraction, and multiplication are
trivial, but the division is protected: if the denominator (right-hand
result) is zero, the function returns one, otherwise it returns the
expected division. For the =<= comparison, the =Node= has an arity of
four (a, b, c, and d), and returns =a < b ? c : d=, that is, if a is
less than b, return c, otherwise return d (the four children are of
course evaluated first). The leaf nodes have an arity of zero, and
return either a constant drawn from a =std::uniform_real_distribution=
with the range =[0, 10]=, or the provided input value =X=. After some
consultation, I may also implement several unary operators: square
root, trigonometric sine, natural logarithm, and natural exponential
function.

The =size()= method of the =Node= recursively counts the number of
internal and leaf nodes, and returns a =Size= struct which is a simple
pair of integers represented the aforementioned counts (I am somewhat
surprised that I am not just using a =std::tuple= here, but the
=struct= fits better).

The construction of the =Node= is quite simple: given the depth, if it
is less than the =Problem='s maximum depth, the =Node= is a assigned a
random non-terminal type (one of =+, -, *, /, <=), and then
recursively adds the necessary number of new =Node= objects to its
children =vector= (two for binary types, four for the conditional). If the
maximum depth has been reached, the node is assigned a random terminal
type (one of constant or input), and does not create any
children. When assigned a constant type, it receives a constant double
value drawn from the aforementioned distribution. Because the =Node=
class is not (yet) derived, internal nodes have some overhead in
the form of the allocated space for a double to hold that constant.

The =print()= method of =Node= class performs a recursive depth-first
post-order traversal, printing the tree's expression to standard out
in Reverse Polish Notation. The =print_formula()= method of the
=Individual= class first prints the total number of nodes, number of
internal nodes, and number of leaf nodes, and then calls the root's
=print()= method to provide the formula. The =print_calculation()=
method is more verbose version of =evaluate()=, where the input/output
pair and respective calculated output are printed as the evaluation
runs. This will be re-factored later into a verbosity option on the
standard =evaluate()= function.

Because this implementation does not use pointers (such as a parent
pointer), when the crossover sequence is implemented, the tree will
have to be walked to the parents of the two subtrees that should be
switched (at which point it can use the efficient =std::swap=);
however, pointers were not going to eliminate that tree traversal. By
freeing myself from pointers, I do not need to worry about freeing
memory during erasure, thus avoiding leaks and hard-to-debug
errors. The default copy constructor of the =Individual= and =Node=
objects are also still available. Each internal (including the root)
=Node= has a vector of children =Node= objects, and the leaf =Node=
objects have an empty vector. Iteration over an empty vector is a
noop, eliminating the necessity of checking for nullptr when
recursing. In a pointer implementation, more memory is actually used
due to the overhead of quite a few pointers, in addition to the
allocation of the objects themselves. If I were to use pointers, in
place of raw pointers, I would use =std::shared_ptr= and
=std::unique_ptr=, which have a safe form of automatic garbage
collection (when the reference count is zero, the object pointed to is
automatically deleted).

* Results

The Genetic Program is working great. In fact, when generating trees
of depth 3, the population of 256 is sufficient to find a random tree
whose function fits the square function (with inputs [0, 16])
exactly. For instance:

#+begin_src text
  Expression tree of size 31 with 13 internals and 18 leafs has the following formula:

  ((((3.0725)(X)(X)(5.33403) a < b ? c : d )((8.11547)(X) * ) /)
  (((2.77921)(8.27688) - )((3.67126)(X) / ) - )(((5.32573)(6.48455) /)
  ((X)(1.18877) + ) * )(((X)(X) * )((X)(X) - ) + ) a < b ? c : d )

  f(0, 0) = 0, error = 0.
  f(1, 1) = 1, error = 0.
  f(2, 4) = 4, error = 0.
  f(3, 9) = 9, error = 0.
  f(4, 16) = 16, error = 0.
  f(5, 25) = 25, error = 0.
  f(6, 36) = 36, error = 0.
  f(7, 49) = 49, error = 0.
  f(8, 64) = 64, error = 0.
  f(9, 81) = 81, error = 0.
  f(10, 100) = 100, error = 0.
  f(11, 121) = 121, error = 0.
  f(12, 144) = 144, error = 0.
  f(13, 169) = 169, error = 0.
  f(14, 196) = 196, error = 0.
  f(15, 225) = 225, error = 0.
  f(16, 256) = 256, error = 0.
  Total fitness: 0.
  Average fitness: 3215.86
  Average size: 23
#+end_src

Trees of this size are created effectively instantly. However, 256
trees of depth 8 (average size of 1959) takes significantly longer to
create and process (about 5 seconds, with another run to depth 12 in
the background), as is to be expected. I feel that I can massively
speed this process up by executing each recursive =Node= construction
(or perhaps each loop of creation of children) in its own thread;
however, I will need to test to see if the cost to sync threads
outweighs their benefits.

* Conclusion

It is definitely working. I have a good framework for the completion
of the final stage of this project, and can even re-use quite a bit of
my Genetic Algorithm implementation. As mentioned earlier, I would
like to implement several unary operators, derive the =Node= class to
eliminate the overhead of the unused double on internal nodes, and
parallelize the tree's creation (and anything else that may benefit).
